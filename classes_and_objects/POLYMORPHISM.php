<?php
/**
 * Created by PhpStorm.
 * User: artem
 * Date: 09.10.18
 * Time: 8:37
 */
////////////////////////////////////////////////////////////////////////////////////////////////////
/****************************************** POLYMORPHISM ******************************************/
////////////////////////////////////////////////////////////////////////////////////////////////////
class A
{
    public function sayHello()
    {
        return 'Hello, I am A';
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/****************************** ПЕРЕОПРЕДЕЛЕНИЕ РОДИТЕЛЬСКОГО МЕТОДА ******************************/
////////////////////////////////////////////////////////////////////////////////////////////////////
class B extends A
{
    public function sayHello()
    {
        return 'Hello, I am B';
        ////////////////////////////////////////////////////////////////////////////////////////////////////
        /*********************************** ВЫЗОВ РОДИТЕЛЬСКОГО МЕТОДА ***********************************/
        /**
         * return parent::sayHello() . '. It was joke, I am B :)'; // Hello, I am A. It was joke, I am B :)
         */
    }
}

$b = new B();

//echo $b->sayHello(); // 'Hello, I am B

/**
 * И ещё один примерчик, тоже искуственный.
 */

class C
{
    public function method1()
    {
        return $this->method2();
    }

    protected function method2()
    {
        return 'C';
    }
}

class D extends C
{
    protected function method2()
    {
        return 'D';
    }
}

$d = new D();

//echo $d->method1(); // D
/**
 * Не знаю, что вы ответили, но он в любом случае выведет D. Внутри метода method1() будет вызван тот метод method2(),
 * который определён для класса, в котором его выполняют. То есть $this не привязан напрямую к классу C. Когда мы
 * вызываем method1() у экземпляра класса D, то $this внутри него будет связан с классом D, и вызовется метод method2(),
 * определенный именно в классе D.
 *
 * И это – тоже полиморфизм. $this привязывается к объекту, в котором код выполняется, а не там, где он был описан.
 */