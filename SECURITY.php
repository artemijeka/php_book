<?php
/**
 * Created by PhpStorm.
 * User: artem
 * Date: 04.09.18
 * Time: 8:41
 */

////////////////////////////////////////////////////////////////////////////////////////////////////
/************************************* Защита от PHP-инъекций *************************************/
/**
 * Можно придумать кучу разных фильтраций. Но я бы посоветовал придерживаться правила –
 * не допускать попадания данных от пользователя в include, require, eval.
 */

////////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************* XSS-атаки *******************************************/
/**
 * Тут история следующая. Например, у вас на сайте есть форма для добавления комментариев.
 * И если вы берёте данные от пользователя, сохраняете их и затем выводите комментарии в неизменном виде,
 * то злоумышленник может попросту вставить в тексте код на JavaScript.

 * Текст комментария. Бла-бла-бла.
 * <script>а тут отправка cookie-файлов на сайт злоумышленника</script>
 * Выход – использовать функцию htmlentities();
 */
echo htmlentities('<script>'); // При выводе ползовательских данных в файлы сайта таких как: комментарии, имена,
// пароли (вообщем любые введенные пользователем данные)
/**
 * Результат: <script>gt;
 */

////////////////////////////////////////////////////////////////////////////////////////////////////
/************************************ Content Security Policy ************************************/
/**
 * Ещё одно решение – использовать заголовки Content Security Policy. Если вкратце – они позволяют ограничить ресурсы,
 * к которым разрешаются разного типа запросы. Можно указать откуда можно использовать ресурсы. Мне по теме CSP нравится
 * вот эта статья https://habr.com/company/nixsolutions/blog/271575/
 *
 * Если вы пока не уверены, стоит ли внедрять у себя CSP, то можно попробовать вместо заголовка Content-Security-Policy
 * использовать Content-Security-Policy-Report-Only. В этом случае CSP будет регистрировать нарушения без какого-либо
 * блокирования ресурсов. Можно даже использовать одновременно Content-Security-Policy и
 * Content-Security-Policy-Report-Only, обкатывая на второй те или иные конфигурации.
 */
/**
 * Прописывание заголовка
 * HTTP-заголовок можно прописать прямо в конфигурационных файлах на сервере:
 */
/** PHP example: */
header("Content-Security-Policy: default-src 'self'");

/** Server example: */
/*
# Apache config
Header set Content-Security-Policy "default-src 'self';"

# IIS Web.config
<system.webServer>
    <httpProtocol>
        <customHeaders>
            <add name="Content-Security-Policy" value="default-src 'self';" />
        </customHeaders>
    </httpProtocol>
</system.webServer>

# nginx conf file
add_header Content-Security-Policy "default-src 'self';";
*/

////////////////////////////////////////////////////////////////////////////////////////////////////
/************************************* Валидация и санитация *************************************/
/**
 * Валидация подразумевает под собой проверку того, что данные являются тем, что мы ожидаем. Например, телефон может
 * быть записан в разных форматах – с плюсиком в начале, с кодом города в скобках, со знаками тире. И тем не менее
 * это будет правильный телефон. Результатом валидации является булево значение – данные либо корректны, либо нет.

 * Санитация позволяет очистить данные от лишней шелухи. На примере с тем же телефоном: независимо от того, что мы
 * передали, в результате санитации будет получена строка вида 79130000000.
 */
/**
 * Нужно всё приводить к нужному типу.
 */
public function view(int $id);

/**
 * Во-вторых – регулярные выражения. В PHP существует много функций для работы с регулярными выражениями.
 * Работают они очень быстро, так как библиотеки для работы с ними написаны на C и работа с регулярками происходит
 * на очень низком уровне.
 */

/**
 * В-третьих, есть встроенная функция filter_var(), которая позволяет как валидировать, так и производить санитацию.
 * http://php.net/manual/ru/function.filter-var.php
 * http://php.net/manual/ru/filter.filters.php
 * Например, чтобы провалидировать email,
 * достаточно написать:
 */
filter_var($email, FILTER_VALIDATE_EMAIL);

////////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************* Шифрование *******************************************/
/**
 * Сейчас в PHP есть специальные функции для хэширования, которые используют современные алгоритмы шифрования.
 * Это функции _passwordhash() и _passwordverify(). Первая функция создаёт хэш для значения.
 */
echo password_hash('password', PASSWORD_DEFAULT); // $2y$10$Ot7AIHSuyDo13Kj6fl2ZOOc7fVCX6fmWx11H6qZQE/J4SLwpN.qQ6
/**
 * Во вторую передаются введенный пароль и хэш, полученный первой функцией. В результате вернётся false или true,
 * в зависимости от того, правильный ли пароль.
 */
var_dump(
    password_verify(
        'password',
        '$2y$10$Ot7AIHSuyDo13Kj6fl2ZOOc7fVCX6fmWx11H6qZQE/J4SLwpN.qQ6'
    )
); // boolean true

////////////////////////////////////////////////////////////////////////////////////////////////////
/****************************************** Репозиторий ******************************************/
/**
 * Игнорить все конфиги в .gitignore сразу при их создании, а лучше вообще выносить их за пределы репозитория.
 */